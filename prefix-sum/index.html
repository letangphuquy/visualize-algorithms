<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minh Họa Mảng Cộng Dồn (Prefix Sum) - Improved</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css"
    />
    <style>
      /* General Styles */
      :root {
        --primary-color: #3498db;
        --secondary-color: #2ecc71;
        --tertiary-color: #e74c3c;
        --array-a-color: #e74c3c; /* Red for array A */
        --array-a-bg: #fef2f0; /* Light red background */
        --array-a-active: #c0392b; /* Darker red for active state */
        --array-s-color: #3498db; /* Blue for array S */
        --array-s-bg: #ebf5fb; /* Light blue background */
        --array-s-active: #2980b9; /* Darker blue for active state */
        --background-color: #f5f5f5;
        --section-bg-color: #ffffff;
        --border-color: #ddd;
        --text-color: #333;
        --highlight-color: #ffeb3b;
        --highlight-secondary: #ffc107;

        /* Query Visualization Colors */
        --query-left-color: #9b59b6; /* Purple for left segment (S[1..L-1]) */
        --query-left-bg: #f4ecf7; /* Light purple background */
        --query-range-color: #f39c12; /* Orange for range segment (S[L..R]) */
        --query-range-bg: #fef5e7; /* Light orange background */
        --query-right-color: #16a085; /* Teal for right segment (S[1..R]) */
        --query-right-bg: #e8f8f5; /* Light teal background */
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      h1 {
        color: var(--primary-color);
        margin-bottom: 15px;
        text-align: center;
      }

      h2 {
        color: var(--primary-color);
        margin-bottom: 15px;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 10px;
      }

      section {
        background-color: var(--section-bg-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      /* Array Input Styles */
      .array-input-container {
        margin-bottom: 20px;
      }

      .array-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        padding: 10px;
        background-color: #f0f0f0;
        border-radius: 8px;
        min-height: 60px;
        align-items: center;
      }

      .array-item {
        display: flex;
        position: relative;
      }

      .array-value {
        width: 50px;
        height: 50px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        text-align: center;
        font-size: 18px;
        padding: 0;
        appearance: none;
        -moz-appearance: textfield;
      }

      .array-value::-webkit-inner-spin-button,
      .array-value::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      .remove-item-btn {
        position: absolute;
        top: -8px;
        right: -8px;
        width: 20px;
        height: 20px;
        background-color: var(--tertiary-color);
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 12px;
        line-height: 1;
        z-index: 1;
      }

      .add-item-btn {
        width: 50px;
        height: 50px;
        background-color: var(--secondary-color);
        color: white;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 24px;
      }

      .array-tools {
        display: flex;
        gap: 10px;
        margin-top: 10px;
        align-items: center;
      }

      .action-btn {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      input[type="number"] {
        width: 60px;
        padding: 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        text-align: center;
      }

      .main-controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 15px;
      }

      .primary-btn {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .secondary-btn {
        background-color: #95a5a6;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      /* Arrays Visualization */
      .visualization-section {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 20px;
        margin-bottom: 20px;
      }

      .animation-container {
        display: flex;
        flex-direction: column;
        height: auto;
        min-height: 300px;
        max-height: 500px;
        overflow: visible;
      }

      .arrays-visualization {
        display: flex;
        flex-direction: column;
        gap: 40px; /* Increased gap for better alignment with indexes */
        margin-bottom: 20px;
        position: relative;
      }

      .array-row {
        display: flex;
        align-items: center;
        gap: 10px;
        height: 70px; /* Fixed height for array rows */
      }

      .array-label {
        font-weight: bold;
        min-width: 30px;
        text-align: right;
        font-size: 18px;
      }

      /* Different colors for A and S arrays */
      .array-label-A {
        color: var(--array-a-color);
      }

      .array-label-S {
        color: var(--array-s-color);
      }

      .array-display {
        display: flex;
        overflow-x: visible;
        overflow-y: visible;
        padding-bottom: 30px; /* Space for indexes */
        height: 70px;
      }

      .array-element {
        width: 50px;
        height: 50px;
        margin-right: 5px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: all 0.3s ease;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      /* Different colors for A and S elements */
      .original-array-element {
        background-color: var(--array-a-bg);
        border: 2px solid var(--array-a-color);
      }

      .prefix-sum-array-element {
        background-color: var(--array-s-bg);
        border: 2px solid var(--array-s-color);
      }

      /* Empty placeholder for array A index 0 */
      .placeholder-element {
        width: 50px;
        height: 50px;
        margin-right: 5px;
        background-color: transparent;
        border: none;
        visibility: hidden;
      }

      .array-element.active {
        transform: translateY(-4px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 10;
        animation: pulse-highlight 0.8s ease-in-out infinite;
      }

      @keyframes pulse-highlight {
        0% {
          transform: translateY(-4px) scale(1);
        }
        50% {
          transform: translateY(-4px) scale(1.1);
        }
        100% {
          transform: translateY(-4px) scale(1);
        }
      }

      .original-array-element.active {
        background-color: #fadbd8; /* Lighter red for active */
        border-color: var(--array-a-active);
      }

      .prefix-sum-array-element.active {
        background-color: #d4e6f1; /* Lighter blue for active */
        border-color: var(--array-s-active);
      }

      .element-value {
        font-size: 18px;
        font-weight: bold;
      }

      .element-index {
        position: absolute;
        bottom: -22px;
        font-size: 12px;
        background-color: #f8f9fa;
        padding: 2px 6px;
        border-radius: 10px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      /* Different colors for A and S indices */
      .original-array-index {
        color: var(--array-a-color);
      }

      .prefix-sum-array-index {
        color: var(--array-s-color);
      }

      /* Animation for collapsing elements */
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      .pulse-animation {
        animation: pulse 0.5s ease-in-out;
      }

      @keyframes slide-elements {
        0% {
          transform: translateY(0);
          opacity: 1;
        }
        50% {
          transform: translateY(-15px);
          opacity: 0.8;
        }
        100% {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .slide-animation {
        animation: slide-elements 0.8s ease-in-out;
      }

      /* Animation Controls Styling */
      .controls-section {
        margin-bottom: 20px;
        padding: 15px;
        background-color: #f0f8ff;
        border-radius: 8px;
        border: 1px solid #d0e3f0;
      }

      .animation-controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 15px;
      }

      .speed-control {
        display: flex;
        align-items: center;
        gap: 10px;
        width: 300px; /* Make slider shorter */
      }

      .speed-control label {
        font-weight: bold;
        width: 130px;
      }

      .speed-control input[type="range"] {
        width: 120px;
      }

      .progress-tracker {
        text-align: center;
        font-weight: bold;
        color: var(--primary-color);
        margin-bottom: 10px;
      }

      .step-controls {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin: 15px 0;
      }

      .step-controls button {
        padding: 8px 15px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
        transition: background-color 0.2s;
      }

      .step-controls button:hover {
        background-color: #2980b9;
      }

      .step-controls button:disabled {
        background-color: #bdc3c7;
        cursor: not-allowed;
      }

      .step-controls button.paused {
        background-color: #f39c12;
      } /* Steps and Explanation Styling */
      .visualization-steps {
        position: relative;
        height: 150px; /* Give enough height for the bubble below */
        margin-top: 0;
        padding: 0;
        z-index: 5;
        pointer-events: none; /* Allow clicks to pass through */
      }

      .visualization-steps > .initial-message {
        pointer-events: auto; /* Allow interaction with the message */
        position: relative;
        top: 30px; /* Position it in the middle of the container */
      }

      .computation-step {
        margin-bottom: 15px;
        padding: 12px;
        background-color: #ffffff;
        border-left: 5px solid var(--primary-color);
        opacity: 0.7;
        transition: all 0.3s ease;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      }

      .computation-step.active {
        opacity: 1;
        border-left-color: var(--secondary-color);
        background-color: #e9f7fe;
      }

      .step-explanation ul {
        list-style-type: none;
        padding-left: 10px;
      }

      .explanation-line {
        padding: 8px 0;
        opacity: 0;
        transform: translateX(-10px);
        transition: all 0.3s ease;
        font-size: 16px;
        line-height: 1.5;
      }

      .explanation-line.active {
        opacity: 1;
        transform: translateX(0);
      }

      .formula-part {
        font-weight: bold;
        padding: 2px 4px;
        border-radius: 3px;
      }

      .formula-A {
        color: var(--array-a-color);
        background-color: var(--array-a-bg);
      }

      .formula-S {
        color: var(--array-s-color);
        background-color: var(--array-s-bg);
      }

      .formula-value {
        font-weight: bold;
      }
      .initial-message {
        text-align: center;
        color: #333;
        font-style: italic;
        padding: 15px 20px;
        background-color: #fff;
        border-radius: 20px;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        position: relative;
        max-width: 80%;
        margin: 0 auto;
        border: 2px solid var(--primary-color);
      }

      .initial-message:after {
        content: "";
        position: absolute;
        top: -15px;
        left: 50%;
        transform: translateX(-50%);
        border-width: 0 15px 15px 15px;
        border-style: solid;
        border-color: var(--primary-color) transparent;
        display: block;
        width: 0;
      }

      .initial-message:before {
        content: "";
        position: absolute;
        top: -12px;
        left: 50%;
        transform: translateX(-50%);
        border-width: 0 13px 13px 13px;
        border-style: solid;
        border-color: #fff transparent;
        display: block;
        width: 0;
        z-index: 1;
      }
      /* Speech bubble styles for active calculations */
      .computation-step {
        text-align: center;
        color: #333;
        padding: 15px 20px;
        background-color: #fff;
        border-radius: 20px;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        position: absolute;
        width: 320px;
        border: 2px solid var(--array-s-color);
        transition: all 0.5s ease-in-out;
        z-index: 10;
        opacity: 0.95;
        bottom: 10px; /* Position below the array */
      }

      /* Top pointer for the speech bubble (points up toward the element) */
      .computation-step:after {
        content: "";
        position: absolute;
        top: -15px;
        left: 50%;
        transform: translateX(-50%);
        border-width: 0 15px 15px 15px;
        border-style: solid;
        border-color: var(--array-s-color) transparent;
        display: block;
        width: 0;
      }

      .computation-step:before {
        content: "";
        position: absolute;
        top: -12px;
        left: 50%;
        transform: translateX(-50%);
        border-width: 0 13px 13px 13px;
        border-style: solid;
        border-color: #fff transparent;
        display: block;
        width: 0;
        z-index: 1;
      }

      /* Query section styles - simplified for space */
      .query-section {
        display: block;
        margin-bottom: 20px;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 20px;
      }

      .query-inputs {
        display: flex;
        gap: 15px;
        align-items: center;
        margin-bottom: 20px;
      }

      .query-input {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .query-input label {
        font-weight: bold;
        font-size: 18px;
      }

      .query-input input {
        width: 60px;
        padding: 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        text-align: center;
      }
      .range-slider-container {
        margin-bottom: 20px;
        padding-top: 10px;
      }

      .range-labels {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        padding: 0 10px;
      }

      .range-slider {
        position: relative;
        height: 80px; /* Increased height for two separate sliders */
        padding: 0 10px;
      }
      .slider-row {
        position: relative;
        height: 35px;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
      }

      .slider-label {
        position: absolute;
        left: -30px;
        font-weight: bold;
        font-size: 18px;
      }

      .slider-row.left-slider .slider-label {
        color: var(--query-left-color);
      }

      .slider-row.right-slider .slider-label {
        color: var(--query-right-color);
      }

      .slider-track {
        position: absolute;
        width: 100%;
        height: 5px;
        background: #ddd;
        border-radius: 5px;
      }

      .slider-handle {
        position: absolute;
        width: 20px;
        height: 20px;
        background: var(--primary-color);
        border-radius: 50%;
        top: -7.5px;
        margin-left: -10px;
        cursor: grab;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .slider-handle:active {
        cursor: grabbing;
      }

      .slider-handle.left-handle {
        background: var(--query-left-color);
      }

      .slider-handle.right-handle {
        background: var(--query-right-color);
      }

      .slider-track {
        position: absolute;
        width: 100%;
        height: 5px;
        background: #ddd;
        border-radius: 5px;
      }

      .slider-handle {
        position: absolute;
        width: 20px;
        height: 20px;
        background: var(--primary-color);
        border-radius: 50%;
        top: -7.5px;
        margin-left: -10px;
        cursor: grab;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .slider-handle:active {
        cursor: grabbing;
      }

      .slider-handle.left-handle {
        background: var(--query-left-color);
      }

      .slider-handle.right-handle {
        background: var(--query-right-color);
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--primary-color);
        cursor: pointer;
        pointer-events: auto;
      }

      .query-result-container {
        background-color: #f9f9f9;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
      }
      .query-formula {
        text-align: center;
        font-size: 20px;
        margin-bottom: 20px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        line-height: 1.8;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        border-left: 5px solid var(--primary-color);
        position: relative;
        cursor: pointer;
        user-select: none;
        transition: background-color 0.3s;
      }

      .query-formula:hover {
        background-color: #f8f8f8;
      }

      .query-formula::after {
        content: "▼";
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 14px;
        color: var(--primary-color);
        transition: transform 0.3s;
      }

      .query-formula.collapsed::after {
        transform: translateY(-50%) rotate(-90deg);
      }

      .formula-text {
        font-size: 18px;
      }

      .formula-value {
        font-weight: bold;
        padding: 3px 8px;
        border-radius: 4px;
        margin: 0 3px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        display: inline-block;
        min-width: 40px;
        text-align: center;
      }

      /* Enhanced formula value styling */
      #formula-sr {
        background-color: var(--query-right-bg);
        color: var(--query-right-color);
        border: 1px solid var(--query-right-color);
      }

      #formula-sl-1 {
        background-color: var(--query-left-bg);
        color: var(--query-left-color);
        border: 1px solid var(--query-left-color);
      }

      #formula-result {
        background-color: var(--query-range-bg);
        color: var(--query-range-color);
        border: 1px solid var(--query-range-color);
        font-size: 22px;
        padding: 5px 10px;
      }
      .query-visualization {
        display: flex;
        flex-direction: column;
        gap: 30px;
        position: relative;
      }

      /* Make the query visualization a linkable section */
      .query-visualization-link {
        cursor: pointer;
        color: var(--primary-color);
        font-weight: bold;
        display: inline-flex;
        align-items: center;
        margin-top: 15px;
        text-decoration: none;
        transition: color 0.2s ease;
        padding: 5px 10px;
        border-radius: 4px;
        background-color: #f0f8ff;
        border: 1px solid #d0e3f0;
      }

      .query-visualization-link:hover {
        color: var(--secondary-color);
        background-color: #e0f0ff;
      }

      .query-visualization-link i {
        margin-right: 5px;
      }

      /* Section title that links back to query inputs */
      .section-link-top {
        cursor: pointer;
        color: var(--primary-color);
        font-weight: bold;
        text-align: right;
        padding: 5px 10px;
        margin-bottom: 10px;
        border-radius: 4px;
        background-color: #f0f8ff;
        border: 1px solid #d0e3f0;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: flex-end;
      }
      .section-link-top:hover {
        color: var(--secondary-color);
        background-color: #e0f0ff;
      }

      .section-link-top i {
        margin-right: 5px;
      }

      /* Smooth scroll behavior for the entire page */
      html {
        scroll-behavior: smooth;
      }

      /* Floating range slider styles */
      .floating-slider-container {
        position: fixed;
        top: 20px;
        right: 20px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        padding: 12px;
        z-index: 1000;
        transform: scale(0.85);
        transform-origin: top right;
        transition: all 0.3s ease;
        opacity: 0;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        max-width: 280px;
        border: 1px solid #e0e0e0;
      }

      .floating-slider-container.visible {
        opacity: 1;
        pointer-events: all;
      }

      .floating-slider-container .floating-label {
        font-weight: bold;
        margin-bottom: 8px;
        color: var(--primary-color);
        font-size: 14px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .floating-slider-container .range-slider {
        width: 100%;
        margin-bottom: 8px;
      }

      .floating-slider-container .slider-row {
        margin-bottom: 5px;
      }

      .floating-slider-container .query-values {
        display: flex;
        justify-content: space-between;
        margin-top: 5px;
        font-size: 13px;
      }

      .floating-slider-container .query-values span {
        background-color: #f0f8ff;
        padding: 2px 8px;
        border-radius: 4px;
        font-weight: bold;
      }

      .query-arrays {
        display: flex;
        flex-direction: column;
        gap: 20px;
        position: relative;
      }

      /* Copy of S array for the query section */
      .query-s-array-row {
        margin-top: 15px;
        border-top: 1px dashed #ccc;
        padding-top: 15px;
      }

      .prefix-segments {
        display: flex;
        flex-direction: column;
        gap: 20px;
        margin-top: 20px;
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.5s ease, opacity 0.3s ease,
          margin-top 0.3s ease;
        opacity: 1;
      }

      .prefix-segments.collapsed {
        max-height: 0;
        opacity: 0;
        margin-top: 0;
      }

      /* L and R indicators on the array */
      .boundary-marker {
        position: absolute;
        top: -15px;
        padding: 2px 8px;
        background-color: #e74c3c;
        color: white;
        font-weight: bold;
        border-radius: 4px;
        font-size: 14px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        z-index: 10;
      }
      .L-marker {
        left: calc(
          var(--L-position) * 55px + 105px - 30px
        ); /* Moved left of the box */
        transform: translateX(0); /* No centering needed */
      }

      .R-marker {
        left: calc(
          var(--R-position) * 55px + 105px
        ); /* Shifted right by one unit (55px) */
        transform: translateX(27.5px); /* Center on the array element */
      }
      .segment {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
        position: relative;
      }

      .segment-label {
        font-weight: bold;
        min-width: 100px;
        border-radius: 4px;
        padding: 6px 10px;
        margin-right: 10px;
        color: white;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      /* Colorful segment labels */
      .segment-label-left {
        background-color: var(--query-left-color);
      }

      .segment-label-range {
        background-color: var(--query-range-color);
      }

      .segment-label-right {
        background-color: var(--query-right-color);
      }

      .segment-display {
        display: flex;
        gap: 5px;
        padding: 10px;
        border-radius: 8px;
        overflow-x: auto;
        align-items: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        min-height: 70px;
        position: relative;
      }

      /* Colorful segment backgrounds */
      .segment-display-left {
        background-color: var(--query-left-bg);
        border-left: 4px solid var(--query-left-color);
      }

      .segment-display-range {
        background-color: var(--query-range-bg);
        border-left: 4px solid var(--query-range-color);
      }

      .segment-display-right {
        background-color: var(--query-right-bg);
        border-left: 4px solid var(--query-right-color);
      }

      /* Placeholder element for alignment in segments */
      .segment-placeholder {
        width: 50px;
        height: 50px;
        margin-right: 5px;
        background-color: transparent;
        border: none;
        visibility: hidden;
      }

      .segment-element {
        width: 50px;
        height: 50px;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        border-radius: 4px;
        color: white;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
      }

      /* Segment element color styles */
      .segment-element-left {
        background-color: var(--query-left-color);
      }

      .segment-element-range {
        background-color: var(--query-range-color);
      }

      .segment-element-right {
        background-color: var(--query-right-color);
      }

      /* Boundary indicators for L and R */
      .boundary-indicator {
        position: absolute;
        top: -25px;
        background-color: #e74c3c;
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        z-index: 10;
      }

      .boundary-L {
        left: 0;
      }

      .boundary-R {
        right: 0;
      }

      .segment-sum {
        margin-left: 15px;
        font-weight: bold;
        font-size: 18px;
        padding: 5px 10px;
        background-color: white;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      }

      /* Different colors for segment sums */
      .segment-sum-left {
        color: var(--query-left-color);
        border-left: 3px solid var(--query-left-color);
      }

      .segment-sum-range {
        color: var(--query-range-color);
        border-left: 3px solid var(--query-range-color);
      }

      .segment-sum-right {
        color: var(--query-right-color);
        border-left: 3px solid var(--query-right-color);
      }

      .empty-segment {
        color: #777;
        font-style: italic;
        padding: 10px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Minh Họa Mảng Cộng Dồn (Prefix Sum)</h1>

      <section class="input-section">
        <h2>Nhập mảng dữ liệu</h2>
        <div class="array-input-container">
          <div id="array-container" class="array-container">
            <!-- Các phần tử mảng sẽ được thêm vào đây -->
            <div class="add-item-btn">+</div>
          </div>
          <div class="array-tools">
            <button id="random-btn" class="action-btn">
              <i class="fas fa-dice"></i> Random
            </button>
            <input
              type="number"
              id="random-size"
              min="1"
              max="15"
              value="8"
              title="Số phần tử ngẫu nhiên"
            />
            <button id="sort-btn" class="action-btn">
              <i class="fas fa-random"></i> Xáo trộn
            </button>
            <button id="clear-btn" class="action-btn">
              <i class="fas fa-trash"></i> Xóa
            </button>
          </div>
        </div>

        <div class="main-controls">
          <button id="compute-btn" class="primary-btn">
            <i class="fas fa-calculator"></i> Tính mảng cộng dồn
          </button>
          <button id="reset-btn" class="secondary-btn">
            <i class="fas fa-redo"></i> Đặt lại
          </button>
        </div>
      </section>

      <!-- Improved Visualization Section -->
      <section class="visualization-section">
        <h2>Minh họa mảng cộng dồn</h2>

        <!-- Controls first -->
        <div
          class="controls-section"
          id="controls-section"
          style="display: none"
        >
          <div class="animation-controls">
            <div class="speed-control">
              <label for="speed">Tốc độ Hoạt hình:</label>
              <input
                type="range"
                id="speed"
                min="100"
                max="2000"
                step="100"
                value="1000"
              />
              <span id="speed-value">1s</span>
            </div>
            <div id="progress-tracker" class="progress-tracker"></div>
          </div>
          <div id="step-controls-container"></div>
        </div>

        <!-- Animation container -->
        <div class="animation-container">
          <!-- Arrays visualization -->
          <div class="arrays-visualization">
            <div class="array-row">
              <div class="array-label array-label-A">A:</div>
              <div id="original-array" class="array-display"></div>
            </div>
            <div class="array-row prefix-sum-row">
              <div class="array-label array-label-S">S:</div>
              <div id="prefix-sum-array" class="array-display"></div>
            </div>
          </div>
          <!-- Current step explanation -->
          <div class="visualization-steps" id="current-step-explanation">
            <div class="initial-message">
              Nhấn "Tính mảng cộng dồn" để xem quá trình tính toán
            </div>
          </div>
        </div>
      </section>

      <!-- Query Section -->
      <section class="query-section" id="query-section">
        <h2>Truy vấn tổng đoạn con</h2>
        <div class="query-inputs">
          <div class="query-input">
            <label for="query-left">L:</label>
            <input type="number" id="query-left" min="1" value="1" />
          </div>
          <div class="query-input">
            <label for="query-right">R:</label>
            <input type="number" id="query-right" min="1" value="1" />
          </div>
          <button id="query-btn" class="primary-btn">
            <i class="fas fa-search"></i> Truy vấn
          </button>
        </div>
        <div class="range-slider-container">
          <div id="range-labels" class="range-labels"></div>
          <div class="range-slider">
            <div class="slider-row left-slider">
              <span class="slider-label">L:</span>
              <div class="slider-track"></div>
              <div id="left-handle" class="slider-handle left-handle"></div>
            </div>
            <div class="slider-row right-slider">
              <span class="slider-label">R:</span>
              <div class="slider-track"></div>
              <div id="right-handle" class="slider-handle right-handle"></div>
            </div>
          </div>
        </div>

        <!-- Floating slider that appears when scrolling -->
        <div id="floating-slider-container" class="floating-slider-container">
          <div class="floating-label">
            <span>Truy vấn tổng đoạn con:</span>
            <span class="query-values">
              <span id="floating-value-left">L=1</span>
              <span id="floating-value-right">R=1</span>
            </span>
          </div>
          <div class="range-slider">
            <div class="slider-row left-slider">
              <span class="slider-label">L:</span>
              <div class="slider-track"></div>
              <div
                id="floating-left-handle"
                class="slider-handle left-handle"
              ></div>
            </div>
            <div class="slider-row right-slider">
              <span class="slider-label">R:</span>
              <div class="slider-track"></div>
              <div
                id="floating-right-handle"
                class="slider-handle right-handle"
              ></div>
            </div>
          </div>
        </div>

        <div class="query-result-container">
          <div id="query-visualization-section" class="query-visualization">
            <div class="query-arrays">
              <div class="array-row query-s-array-row">
                <div class="array-label array-label-S">S:</div>
                <div id="query-prefix-sum-array" class="array-display"></div>
              </div>
              <div class="array-row">
                <div class="array-label array-label-A">A:</div>
                <div id="query-original-array" class="array-display"></div>
              </div>
            </div>
            <div class="query-formula" id="query-formula-toggle">
              <span class="formula-text">Tổng[L..R] = S[R] - S[L-1] = </span>
              <span id="formula-sr" class="formula-value formula-S"></span>
              <span class="formula-text"> - </span>
              <span id="formula-sl-1" class="formula-value formula-S"></span>
              <span class="formula-text"> = </span>
              <span id="formula-result" class="formula-value result"></span>
            </div>
            <div
              class="prefix-segments collapsed"
              id="prefix-segments-container"
            >
              <div class="segment">
                <div class="segment-label segment-label-right">A[1..R]:</div>
                <div
                  id="segment-right"
                  class="segment-display segment-display-right"
                ></div>
              </div>
              <div class="segment">
                <div class="segment-label segment-label-left">A[1..L-1]:</div>
                <div
                  id="segment-left"
                  class="segment-display segment-display-left"
                ></div>
              </div>
              <div class="segment">
                <div class="segment-label segment-label-range">A[L..R]:</div>
                <div
                  id="segment-middle"
                  class="segment-display segment-display-range"
                ></div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Hidden section for tracking computation history (not visible) -->
      <div style="display: none" id="computation-steps-history"></div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // Create and set up the PrefixSumVisualization object
        window.PrefixSumVisualization = {
          // Animation speed control (milliseconds)
          animationSpeed: 1000,

          // Animation control variables
          steps: [],
          currentStep: 0,
          animationInterval: null,
          isPaused: false,
          isAnimating: false,

          // References to key DOM elements
          elements: {
            arrayContainer: null,
            generateRandomBtn: null,
            randomSizeInput: null,
            sortBtn: null,
            clearBtn: null,
            computePrefixSumBtn: null,
            resetBtn: null,
            originalArrayContainer: null,
            prefixSumArrayContainer: null,
            currentStepExplanation: null, // New element for current step only
            computationStepsHistory: null, // Hidden element for history
            controlsSection: null,
            speedSlider: null,
            speedValue: null,
            progressTracker: null,
          },
          // Initialize the application
          init() {
            this.cacheElements();
            this.setupEventListeners();
            this.generateRandomArray();

            // Track which slider was moved last
            this.lastSliderMoved = "left";

            // Setup draggable sliders
            this.setupDraggableHandles();

            // Set up the floating range slider
            this.setupFloatingRangeSlider();
          },
          // Setup draggable slider handles
          setupDraggableHandles() {
            if (!this.elements.leftHandle || !this.elements.rightHandle) return;

            // Define min/max/value properties for our handles
            this.handleValues = {
              left: { min: 1, max: 1, value: 1 },
              right: { min: 1, max: 1, value: 1 },
            };

            const setupDragging = (handle, isLeft) => {
              let isDragging = false;
              const sliderTrack = handle
                .closest(".slider-row")
                .querySelector(".slider-track");

              const updateHandlePosition = (e) => {
                if (!isDragging) return;

                const trackRect = sliderTrack.getBoundingClientRect();
                let position = (e.clientX - trackRect.left) / trackRect.width;
                position = Math.max(0, Math.min(1, position));

                const handleInfo = isLeft
                  ? this.handleValues.left
                  : this.handleValues.right;
                const min = handleInfo.min;
                const max = handleInfo.max;
                const value = Math.round(min + position * (max - min));

                // Update handle value
                handleInfo.value = value;

                // Update handle position
                const handlePosition = ((value - min) / (max - min)) * 100;
                handle.style.left = `${handlePosition}%`;

                // Update which slider was moved last
                this.lastSliderMoved = isLeft ? "left" : "right";

                // Update the query based on the handle positions
                this.updateQueryFromHandles();
              };

              handle.addEventListener("mousedown", (e) => {
                isDragging = true;
                handle.style.cursor = "grabbing";
                e.preventDefault(); // Prevent text selection
              });

              document.addEventListener("mousemove", updateHandlePosition);

              document.addEventListener("mouseup", () => {
                if (isDragging) {
                  isDragging = false;
                  handle.style.cursor = "grab";
                }
              });

              // Function to update handle position based on its value
              const updateHandleVisualPosition = () => {
                const handleInfo = isLeft
                  ? this.handleValues.left
                  : this.handleValues.right;
                const min = handleInfo.min;
                const max = handleInfo.max;
                const value = handleInfo.value;
                const position = ((value - min) / (max - min)) * 100;
                handle.style.left = `${position}%`;
              };

              // Initial position
              updateHandleVisualPosition();

              // Store the update function for later use
              if (isLeft) {
                this.updateLeftHandlePosition = updateHandleVisualPosition;
              } else {
                this.updateRightHandlePosition = updateHandleVisualPosition;
              }
            };

            // Setup drag functionality for both handles
            setupDragging(this.elements.leftHandle, true);
            setupDragging(this.elements.rightHandle, false);
          },
          setupDragging(handle, isLeft, isFloating = false) {
            let isDragging = false;
            const sliderTrack = handle
              .closest(".slider-row")
              .querySelector(".slider-track");

            const updateHandlePosition = (e) => {
              if (!isDragging) return;

              const trackRect = sliderTrack.getBoundingClientRect();
              let position = (e.clientX - trackRect.left) / trackRect.width;
              position = Math.max(0, Math.min(1, position));

              // Use the handleValues object
              const min = this.handleValues[isLeft ? "left" : "right"].min;
              const max = this.handleValues[isLeft ? "left" : "right"].max;
              let value = Math.round(min + position * (max - min));

              // Ensure left handle doesn't go beyond right, and vice versa
              if (isLeft && value > this.handleValues.right.value) {
                value = this.handleValues.right.value;
              } else if (!isLeft && value < this.handleValues.left.value) {
                value = this.handleValues.left.value;
              }

              // Update handle value in our object
              this.handleValues[isLeft ? "left" : "right"].value = value;

              // Update which slider was moved last
              this.lastSliderMoved = isLeft ? "left" : "right";

              // Update both floating and regular sliders
              this.updateAllSliders();
            };

            handle.addEventListener("mousedown", (e) => {
              isDragging = true;
              handle.style.cursor = "grabbing";
              e.preventDefault(); // Prevent text selection
            });

            document.addEventListener("mousemove", updateHandlePosition);

            document.addEventListener("mouseup", () => {
              if (isDragging) {
                isDragging = false;
                handle.style.cursor = "grab";
              }
            });

            // Update handle position visually based on handleValues object
            const updateVisualPosition = () => {
              const min = this.handleValues[isLeft ? "left" : "right"].min;
              const max = this.handleValues[isLeft ? "left" : "right"].max;
              const value = this.handleValues[isLeft ? "left" : "right"].value;
              const position = ((value - min) / (max - min)) * 100;
              handle.style.left = `${position}%`;
            };

            // Set initial position
            updateVisualPosition();
          },

          // Cache DOM elements for later use
          cacheElements() {
            this.elements.arrayContainer =
              document.getElementById("array-container");
            this.elements.generateRandomBtn =
              document.getElementById("random-btn");
            this.elements.randomSizeInput =
              document.getElementById("random-size");
            this.elements.sortBtn = document.getElementById("sort-btn");
            this.elements.clearBtn = document.getElementById("clear-btn");
            this.elements.computePrefixSumBtn =
              document.getElementById("compute-btn");
            this.elements.resetBtn = document.getElementById("reset-btn");
            this.elements.originalArrayContainer =
              document.getElementById("original-array");
            this.elements.prefixSumArrayContainer =
              document.getElementById("prefix-sum-array");
            this.elements.currentStepExplanation = document.getElementById(
              "current-step-explanation"
            );
            this.elements.computationStepsHistory = document.getElementById(
              "computation-steps-history"
            );
            this.elements.controlsSection =
              document.getElementById("controls-section");
            this.elements.speedSlider = document.getElementById("speed");
            this.elements.speedValue = document.getElementById("speed-value");
            this.elements.progressTracker =
              document.getElementById("progress-tracker");
            // Query section elements
            this.elements.querySection =
              document.getElementById("query-section");
            this.elements.queryLInput = document.getElementById("query-left");
            this.elements.queryRInput = document.getElementById("query-right");
            this.elements.executeQueryBtn = document.getElementById("query-btn");
            this.elements.leftHandle = document.getElementById("left-handle");
            this.elements.rightHandle = document.getElementById("right-handle");
            this.elements.rangeLabels = document.getElementById("range-labels");
            this.elements.formulaSR = document.getElementById("formula-sr");
            this.elements.formulaSL1 = document.getElementById("formula-sl-1");
            this.elements.formulaResult =
              document.getElementById("formula-result");
            this.elements.queryOriginalArray = document.getElementById(
              "query-original-array"
            );
            this.elements.queryPrefixSumArray = document.getElementById(
              "query-prefix-sum-array"
            );
            this.elements.queryArrays = document.querySelector(".query-arrays");
            this.elements.segmentLeft = document.getElementById("segment-left");
            this.elements.segmentMiddle =
              document.getElementById("segment-middle");
            this.elements.segmentRight =
              document.getElementById("segment-right");

            // Elements for collapsible segments
            this.elements.queryFormulaToggle = document.getElementById(
              "query-formula-toggle"
            );
            this.elements.prefixSegmentsContainer = document.getElementById(
              "prefix-segments-container"
            );

            // Floating slider elements
            this.elements.floatingSliderContainer = document.getElementById(
              "floating-slider-container"
            );
            this.elements.floatingLeftHandle = document.getElementById(
              "floating-left-handle"
            );
            this.elements.floatingRightHandle = document.getElementById(
              "floating-right-handle"
            );
            this.elements.rangeSliderContainer = document.querySelector(
              ".range-slider-container"
            );
            this.elements.floatingValueLeft = document.getElementById(
              "floating-value-left"
            );
            this.elements.floatingValueRight = document.getElementById(
              "floating-value-right"
            );
          },

          // Set up event listeners
          setupEventListeners() {
            // Generate random array button
            if (this.elements.generateRandomBtn) {
              this.elements.generateRandomBtn.addEventListener("click", () => {
                const size = this.elements.randomSizeInput
                  ? parseInt(this.elements.randomSizeInput.value)
                  : 8;
                this.generateRandomArray(size);
              });
            }

            // Sort array button (Shuffle)
            if (this.elements.sortBtn) {
              this.elements.sortBtn.addEventListener("click", () => {
                this.shuffleArray();
              });
            }

            // Clear array button
            if (this.elements.clearBtn) {
              this.elements.clearBtn.addEventListener("click", () => {
                this.clearArray();
              });
            }

            // Compute prefix sum button
            if (this.elements.computePrefixSumBtn) {
              this.elements.computePrefixSumBtn.addEventListener(
                "click",
                () => {
                  this.computeAndVisualizePrefixSum();
                }
              );
            }

            // Reset button
            if (this.elements.resetBtn) {
              this.elements.resetBtn.addEventListener("click", () => {
                this.resetVisualization();
              });
            }

            // Animation speed control
            if (this.elements.speedSlider) {
              this.elements.speedSlider.addEventListener("input", () => {
                const speedValue = this.elements.speedSlider.value;
                this.animationSpeed = parseInt(speedValue);
                this.elements.speedValue.textContent = speedValue / 1000 + "s";

                // Update interval if animation is running
                if (this.animationInterval) {
                  clearInterval(this.animationInterval);
                  if (!this.isPaused) {
                    this.animationInterval = setInterval(
                      () => this.nextStep(),
                      this.animationSpeed
                    );
                  }
                }
              });
            }
            // Execute query button
            if (this.elements.executeQueryBtn) {
              this.elements.executeQueryBtn.addEventListener("click", () => {
                this.executeAndVisualizeQuery();
              });
            }

            // Manual query input
            if (this.elements.queryLInput && this.elements.queryRInput) {
              this.elements.queryLInput.addEventListener("change", () => {
                this.updateHandlesFromQuery();
              });

              this.elements.queryRInput.addEventListener("change", () => {
                this.updateHandlesFromQuery();
              });
            }

            // Add item button
            const addBtn = this.elements.arrayContainer
              ? this.elements.arrayContainer.querySelector(".add-item-btn")
              : null;

            if (addBtn) {
              addBtn.addEventListener("click", () => {
                this.addArrayElement();
              });
            }

            // Set up event delegation for array item interactions
            if (this.elements.arrayContainer) {
              this.elements.arrayContainer.addEventListener("click", (e) => {
                if (e.target.classList.contains("remove-item-btn")) {
                  const arrayItem = e.target.closest(".array-item");
                  if (arrayItem) {
                    this.removeArrayElement(arrayItem);
                  }
                }
              });
            }
            // Set up toggling for prefix segments
            const formulaToggle = document.getElementById(
              "query-formula-toggle"
            );
            const prefixSegmentsContainer = document.getElementById(
              "prefix-segments-container"
            );            if (formulaToggle && prefixSegmentsContainer) {
              formulaToggle.addEventListener("click", () => {
                formulaToggle.classList.toggle("collapsed");
                prefixSegmentsContainer.classList.toggle("collapsed");
                
                // If the toggle is not collapsed (open), scroll to query-visualization section
                if (!formulaToggle.classList.contains("collapsed")) {
                  setTimeout(() => {
                    const queryVisualizationSection = document.getElementById(
                      "query-visualization-section"
                    );
                    if (queryVisualizationSection) {
                      queryVisualizationSection.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                      });
                    }
                  }, 100);
                }
              });
            }
            // Remove event listener for query visualization link as we've removed the link
            // We're removing the "Trở lại bộ điều khiển" button at the top of the visualization section
          },

          // Generate a random array
          generateRandomArray(size = 8) {
            // Random array utility function
            const generateRandomArray = (size, min, max) => {
              const arr = [];
              for (let i = 0; i < size; i++) {
                arr.push(Math.floor(Math.random() * (max - min + 1)) + min);
              }
              return arr;
            };

            const randomArray = generateRandomArray(size, 1, 10);

            // Clear the existing array container
            this.clearArrayContainer();

            // Create array items for each element
            randomArray.forEach((value) => {
              this.addArrayElement(value);
            });

            // Clear previous prefix sum and computation steps
            this.resetVisualization();
          },

          // Clear the array container
          clearArrayContainer() {
            if (this.elements.arrayContainer) {
              // Keep only the add button
              const addBtn =
                this.elements.arrayContainer.querySelector(".add-item-btn");
              this.elements.arrayContainer.innerHTML = "";
              if (addBtn) {
                this.elements.arrayContainer.appendChild(addBtn);
              } else {
                // If add button was removed, create a new one
                const newAddBtn = document.createElement("div");
                newAddBtn.className = "add-item-btn";
                newAddBtn.textContent = "+";
                this.elements.arrayContainer.appendChild(newAddBtn);

                // Add event listener to the new button
                newAddBtn.addEventListener("click", () => {
                  this.addArrayElement();
                });
              }
            }
          },

          // Clear the array
          clearArray() {
            this.clearArrayContainer();
            this.resetVisualization();
          },
          // Reset the visualization components
          resetVisualization() {
            if (this.elements.prefixSumArrayContainer) {
              this.elements.prefixSumArrayContainer.innerHTML = "";
            }

            if (this.elements.currentStepExplanation) {
              this.elements.currentStepExplanation.innerHTML =
                '<div class="initial-message">Nhấn "Tính mảng cộng dồn" để xem quá trình tính toán</div>';
            }

            if (this.elements.computationStepsHistory) {
              this.elements.computationStepsHistory.innerHTML = "";
            } // Hide query section
            if (this.elements.querySection) {
              this.elements.querySection.style.display = "none";
              // Clean up any boundary markers to prevent overlays on next visualization
              if (this.elements.queryArrays) {
                const existingMarkers =
                  this.elements.queryArrays.querySelectorAll(
                    ".boundary-marker"
                  );
                existingMarkers.forEach((marker) => marker.remove());
              }

              // Also clean up any boundary indicators
              const boundaryIndicators = document.querySelectorAll(
                ".boundary-indicator"
              );
              boundaryIndicators.forEach((indicator) => indicator.remove());
            }

            // Clear any animations
            clearInterval(this.animationInterval);
            this.isAnimating = false;
            this.steps = [];
            this.currentStep = 0;

            // Hide controls section
            if (this.elements.controlsSection) {
              this.elements.controlsSection.style.display = "none";
            }

            // Remove step controls if they exist
            const stepControls = document.querySelector(".step-controls");
            if (stepControls) {
              stepControls.remove();
            }
          },

          // Add an array element to the UI
          addArrayElement(value = 0) {
            if (!this.elements.arrayContainer) return;

            // Create array item
            const arrayItem = document.createElement("div");
            arrayItem.className = "array-item";

            // Create input for the value
            const input = document.createElement("input");
            input.type = "number";
            input.className = "array-value";
            input.value = value;
            input.min = 0;
            input.max = 99;

            // Create remove button
            const removeBtn = document.createElement("div");
            removeBtn.className = "remove-item-btn";
            removeBtn.innerHTML = "&times;";

            // Append to array item
            arrayItem.appendChild(input);
            arrayItem.appendChild(removeBtn);

            // Find add button
            const addBtn =
              this.elements.arrayContainer.querySelector(".add-item-btn");

            // Insert before the add button if found, otherwise append to container
            if (addBtn) {
              this.elements.arrayContainer.insertBefore(arrayItem, addBtn);
            } else {
              this.elements.arrayContainer.appendChild(arrayItem);
            }

            // Add event listener to remove button
            removeBtn.addEventListener("click", () => {
              this.removeArrayElement(arrayItem);

              // Reset visualizations since array changed
              this.resetVisualization();
            });
          },

          // Remove an array element from the UI
          removeArrayElement(arrayItem) {
            if (this.elements.arrayContainer && arrayItem) {
              this.elements.arrayContainer.removeChild(arrayItem);
            }
          },

          // Get the array from the UI inputs
          getArrayFromUI() {
            if (!this.elements.arrayContainer) return [];

            const arrayItems =
              this.elements.arrayContainer.querySelectorAll(".array-item");
            const array = [];

            arrayItems.forEach((item) => {
              const input = item.querySelector(".array-value");
              if (input) {
                const value = parseInt(input.value) || 0;
                array.push(value);
              }
            });

            return array;
          },
          // Compute and visualize prefix sum
          computeAndVisualizePrefixSum() {
            // Check if already animating
            if (this.isAnimating) return;

            const array = this.getArrayFromUI();
            if (array.length === 0) {
              alert("Vui lòng nhập ít nhất một phần tử cho mảng!");
              return;
            }

            // Reset visualization
            this.resetVisualization();
            this.isAnimating = true;

            // Visualize the original array
            this.visualizeOriginalArray(array);

            // Initialize the prefix sum calculator
            this.initializePrefixSum(array);

            // Show controls section
            if (this.elements.controlsSection) {
              this.elements.controlsSection.style.display = "block";
            }

            // Create step controls
            this.createStepControls();

            // Generate steps for visualization
            this.prepareAnimationSteps();

            // Start the animation
            this.startAnimation();

            // Update query range sliders with the new array size
            this.updateQueryRangeControls(array.length);
          },

          // Initialize prefix sum calculation
          initializePrefixSum(array) {
            // Store original array
            this.originalArray = [...array];

            // Calculate prefix sum
            this.prefixSumArray = [0]; // Start with S[0] = 0
            let sum = 0;

            for (let i = 0; i < array.length; i++) {
              sum += array[i];
              this.prefixSumArray.push(sum);
            }

            // Generate computation steps
            this.computationSteps = [];

            // Add initial step S[0] = 0
            this.computationSteps.push({
              position: 0,
              value: 0,
              currentPrefixSum: 0,
              previousPrefixSum: 0,
              originalPosition: -1,
            });

            // Add steps for each calculation
            for (let i = 0; i < array.length; i++) {
              this.computationSteps.push({
                position: i + 1,
                value: array[i],
                currentPrefixSum: this.prefixSumArray[i + 1],
                previousPrefixSum: this.prefixSumArray[i],
                originalPosition: i,
              });
            }
          },

          // Create step controls for animation
          createStepControls() {
            // Remove existing controls if any
            const existingControls = document.querySelector(".step-controls");
            if (existingControls) {
              existingControls.remove();
            }

            // Create new controls
            const controlsDiv = document.createElement("div");
            controlsDiv.className = "step-controls";
            controlsDiv.innerHTML = `
                        <button id="start-btn" title="Đi đến bước đầu tiên"><i>⏮</i> Bắt đầu</button>
                        <button id="prev-step" disabled title="Đi đến bước trước đó"><i>◀</i> Lùi</button>
                        <button id="pause-animation" title="Tạm dừng/Tiếp tục hoạt hình"><i>⏯</i> Tạm dừng</button>
                        <button id="next-step" disabled title="Đi đến bước tiếp theo">Tiếp <i>▶</i></button>
                        <button id="finish-btn" title="Bỏ qua đến kết quả cuối cùng"><i>⏭</i> Kết thúc</button>
                    `;

            // Insert into step-controls-container
            const container = document.getElementById(
              "step-controls-container"
            );
            if (container) {
              container.appendChild(controlsDiv);
            }

            // Set up button click handlers
            document
              .getElementById("start-btn")
              .addEventListener("click", () => this.goToStart());
            document
              .getElementById("prev-step")
              .addEventListener("click", () => this.prevStep());
            document
              .getElementById("pause-animation")
              .addEventListener("click", () => this.togglePause());
            document
              .getElementById("next-step")
              .addEventListener("click", () => {
                if (this.currentStep < this.steps.length - 1) {
                  this.nextStep(true); // Pass true to indicate manual navigation
                }
              });
            document
              .getElementById("finish-btn")
              .addEventListener("click", () => this.skipToFinish());
          },

          // Prepare animation steps
          prepareAnimationSteps() {
            this.steps = [];

            // Add initial state step
            this.steps.push({
              prefixSum: [0], // Start with just S[0] = 0
              currentPrefixSumIndex: 0,
              originalArrayIndex: -1, // No element highlighted yet
              explanation: [
                "Bắt đầu tính toán mảng cộng dồn",
                "S[0] = 0 (khởi tạo)",
              ],
            });

            // Add steps for each computation
            for (let i = 1; i < this.computationSteps.length; i++) {
              const step = this.computationSteps[i];

              // Create a copy of the prefix sum array up to the current position
              const currentPrefixSum = this.prefixSumArray.slice(
                0,
                step.position + 1
              );

              this.steps.push({
                prefixSum: currentPrefixSum,
                currentPrefixSumIndex: step.position,
                originalArrayIndex: step.originalPosition,
                explanation: [
                  `S[${step.position}] = S[${step.position - 1}] + A[${
                    step.originalPosition + 1
                  }]`,
                  `S[${step.position}] = ${step.previousPrefixSum} + ${step.value} = ${step.currentPrefixSum}`,
                ],
              });
            }

            this.currentStep = 0;
          },

          // Start the animation
          startAnimation() {
            // Clear any existing animation
            clearInterval(this.animationInterval);
            this.isPaused = false;

            // Reset UI controls
            const pauseBtn = document.getElementById("pause-animation");
            const prevBtn = document.getElementById("prev-step");
            const nextBtn = document.getElementById("next-step");

            if (pauseBtn) {
              pauseBtn.textContent = "⏯ Tạm dừng";
              pauseBtn.classList.remove("paused");
            }

            if (prevBtn) prevBtn.disabled = true;
            if (nextBtn) nextBtn.disabled = true;

            this.currentStep = 0;
            this.displayStep();
            this.updateProgressTracker();

            // Start the animation timer
            this.animationInterval = setInterval(
              () => this.nextStep(),
              this.animationSpeed
            );
          },

          // Toggle animation pause state
          togglePause() {
            const pauseBtn = document.getElementById("pause-animation");

            if (this.isPaused) {
              // Resume animation if we have more steps
              if (this.currentStep < this.steps.length - 1) {
                this.animationInterval = setInterval(
                  () => this.nextStep(),
                  this.animationSpeed
                );
              }
              // Update UI
              if (pauseBtn) {
                pauseBtn.textContent = "⏯ Tạm dừng";
                pauseBtn.classList.remove("paused");
              }
            } else {
              // Pause animation
              clearInterval(this.animationInterval);
              // Update UI
              if (pauseBtn) {
                pauseBtn.textContent = "⏯ Tiếp tục";
                pauseBtn.classList.add("paused");
              }
            }

            this.isPaused = !this.isPaused;

            // Enable navigation buttons when paused, with proper boundary checks
            const prevBtn = document.getElementById("prev-step");
            const nextBtn = document.getElementById("next-step");

            if (prevBtn)
              prevBtn.disabled = !this.isPaused || this.currentStep <= 0;
            if (nextBtn)
              nextBtn.disabled =
                !this.isPaused || this.currentStep >= this.steps.length - 1;
          },

          // Go to first step
          goToStart() {
            clearInterval(this.animationInterval);
            this.currentStep = 0;
            this.displayStep();
            this.updateProgressTracker();

            // Update button states
            const prevBtn = document.getElementById("prev-step");
            const nextBtn = document.getElementById("next-step");
            const pauseBtn = document.getElementById("pause-animation");

            if (prevBtn) prevBtn.disabled = true;
            if (nextBtn) nextBtn.disabled = false;
            if (pauseBtn) {
              pauseBtn.textContent = "⏯ Tiếp tục";
              pauseBtn.classList.add("paused");
            }

            this.isPaused = true;
          },

          // Skip to finish
          skipToFinish() {
            clearInterval(this.animationInterval);
            this.currentStep = this.steps.length - 1;
            this.displayStep();
            this.updateProgressTracker();

            // Update button states
            const prevBtn = document.getElementById("prev-step");
            const nextBtn = document.getElementById("next-step");
            const pauseBtn = document.getElementById("pause-animation");

            if (prevBtn) prevBtn.disabled = false;
            if (nextBtn) nextBtn.disabled = true;
            if (pauseBtn) {
              pauseBtn.textContent = "⏯ Tiếp tục";
              pauseBtn.classList.add("paused");
            }

            this.isPaused = true;
          },

          // Move to the next step in animation
          nextStep(isManual = false) {
            // Prevent stepping beyond array bounds
            if (this.currentStep >= this.steps.length - 1) {
              // If at the last step, stop the animation
              clearInterval(this.animationInterval);
              this.updateProgressTracker();
              return;
            }

            this.currentStep++;
            this.displayStep();
            this.updateProgressTracker();

            // If manual navigation, update button states
            if (isManual) {
              const prevBtn = document.getElementById("prev-step");
              const nextBtn = document.getElementById("next-step");

              if (prevBtn) prevBtn.disabled = this.currentStep <= 0;
              if (nextBtn)
                nextBtn.disabled = this.currentStep >= this.steps.length - 1;
            }
          },

          // Move to the previous step in animation
          prevStep() {
            // Prevent stepping before first step
            if (this.currentStep <= 0) return;

            this.currentStep--;
            this.displayStep();
            this.updateProgressTracker();

            // Update button states
            const prevBtn = document.getElementById("prev-step");
            const nextBtn = document.getElementById("next-step");

            if (nextBtn) nextBtn.disabled = false; // Next is always available if we went back
            if (prevBtn) prevBtn.disabled = this.currentStep <= 0;
          },

          // Update the progress tracker display
          updateProgressTracker() {
            if (this.elements.progressTracker) {
              this.elements.progressTracker.textContent = `Bước ${
                this.currentStep + 1
              } / ${this.steps.length}`;
            }
          },
          // Display the current step
          displayStep() {
            if (
              this.steps.length === 0 ||
              this.currentStep >= this.steps.length
            )
              return;

            const step = this.steps[this.currentStep];

            // Visualize the current state of the prefix sum array
            this.visualizePrefixSumArray(step.prefixSum);

            // Highlight the relevant elements
            this.removeAllHighlights();

            // For step > 0, animate the calculation
            if (
              this.currentStep > 0 &&
              step.originalArrayIndex >= 0 &&
              step.currentPrefixSumIndex >= 0
            ) {
              // First highlight the original array element being added
              const originalElement = this.highlightArrayElement(
                "original-array",
                step.originalArrayIndex
              );

              // Then highlight the previous sum element
              const prevSumIndex = step.currentPrefixSumIndex - 1;
              const prevSumElement = this.highlightArrayElement(
                "prefix-sum-array",
                prevSumIndex
              );

              // Finally highlight the current sum element with a pulse animation
              const currentSumElement = this.highlightArrayElement(
                "prefix-sum-array",
                step.currentPrefixSumIndex
              );

              if (currentSumElement) {
                currentSumElement.classList.add("pulse-animation");
                // Remove animation class after animation completes
                setTimeout(() => {
                  if (currentSumElement) {
                    currentSumElement.classList.remove("pulse-animation");
                  }
                }, 500);
              }
            } else if (
              this.currentStep === 0 &&
              step.currentPrefixSumIndex >= 0
            ) {
              // Just highlight S[0] for the initial step
              const initialElement = this.highlightArrayElement(
                "prefix-sum-array",
                0
              );
              if (initialElement) {
                initialElement.classList.add("pulse-animation");
                setTimeout(() => {
                  if (initialElement) {
                    initialElement.classList.remove("pulse-animation");
                  }
                }, 500);
              }
            }

            // Update the CURRENT STEP explanation display
            this.displayCurrentStepExplanation(step);

            // Record step in history (hidden)
            this.recordStepInHistory(step);
          },

          // Remove all highlights
          removeAllHighlights() {
            const elements = document.querySelectorAll(".array-element");
            elements.forEach((el) => {
              el.classList.remove("active");
            });
          }, // Display current step explanation
          displayCurrentStepExplanation(step) {
            if (!this.elements.currentStepExplanation) return;

            // Clear current explanation
            this.elements.currentStepExplanation.innerHTML = "";

            const stepElement = document.createElement("div");
            stepElement.className = "computation-step active";

            // Add explanation lines for the CURRENT step only
            if (step.explanation && step.explanation.length) {
              // Format the explanation with colored formula parts
              const formattedExplanation = step.explanation.map((line) => {
                // Replace S[i] patterns with colored spans
                let formattedLine = line.replace(
                  /S\[(\d+)\]/g,
                  '<span class="formula-part formula-S">S[$1]</span>'
                );
                // Replace A[i] patterns with colored spans
                formattedLine = formattedLine.replace(
                  /A\[(\d+)\]/g,
                  '<span class="formula-part formula-A">A[$1]</span>'
                );
                return formattedLine;
              });

              const explanationHtml = `
                            <div class="step-explanation">
                                <ul>
                                    ${formattedExplanation
                                      .map(
                                        (line) =>
                                          `<li class="explanation-line active">${line}</li>`
                                      )
                                      .join("")}
                                </ul>
                            </div>
                        `;
              stepElement.innerHTML = explanationHtml;
            }

            // Add to the current step explanation container
            this.elements.currentStepExplanation.appendChild(stepElement);

            // Position the speech bubble above the active array element
            this.positionSpeechBubble(step);
          }, // Position the speech bubble above the active prefix sum element

          positionSpeechBubble(step) {
            const bubbleElement = document.querySelector(".computation-step");
            if (!bubbleElement) return;

            // For initial step (S[0])
            if (this.currentStep === 0) {
              const initialElement = document.querySelector(
                "#prefix-sum-array .array-element"
              );
              if (initialElement) {
                // Get accurate position using getBoundingClientRect instead of offsetLeft
                const rect = initialElement.getBoundingClientRect();
                const containerRect =
                  this.elements.currentStepExplanation.getBoundingClientRect();

                // Calculate position relative to the container, accounting for scroll position
                const adjustedLeft =
                  rect.left -
                  containerRect.left +
                  window.scrollX +
                  rect.width / 2;
                bubbleElement.style.left = `${
                  adjustedLeft - bubbleElement.offsetWidth / 2
                }px`;

                // Remove any previous transform that might interfere with positioning
                bubbleElement.style.transform = "";
              } else {
                // Center for initial message if array not visible yet
                bubbleElement.style.left = "50%";
                bubbleElement.style.transform = "translateX(-50%)";
              }
            }
            // For calculation steps, position below the current S[i] element being calculated
            else if (step.currentPrefixSumIndex >= 0) {
              // Get element by index, not by nth-child which was causing issues for indices 1 and 2
              const elements = document.querySelectorAll(
                "#prefix-sum-array .array-element"
              );
              const prefixSumElement = elements[step.currentPrefixSumIndex];

              if (prefixSumElement) {
                // Get accurate position using getBoundingClientRect
                const elementRect = prefixSumElement.getBoundingClientRect();
                const containerRect =
                  this.elements.currentStepExplanation.getBoundingClientRect();
                const prefixSumContainerRect =
                  this.elements.prefixSumArrayContainer.getBoundingClientRect();

                // Calculate position relative to the container, accounting for scroll position
                const adjustedLeft =
                  elementRect.left -
                  containerRect.left +
                  window.scrollX +
                  elementRect.width / 2;
                bubbleElement.style.left = `${
                  adjustedLeft - bubbleElement.offsetWidth / 2
                }px`;

                // Remove any transform that might interfere with positioning
                bubbleElement.style.transform = "";

                // // Ensure bubble doesn't go off left edge
                // const bubbleRect = bubbleElement.getBoundingClientRect();
                // if (bubbleRect.left < prefixSumContainerRect.left + 20) {
                //     const minLeft = prefixSumContainerRect.left - containerRect.left + 20 + window.scrollX;
                //     bubbleElement.style.left = `${minLeft}px`;
                // }

                // // Ensure bubble doesn't go off right edge
                // if (bubbleRect.right > prefixSumContainerRect.right - 20) {
                //     const maxLeft = prefixSumContainerRect.right - containerRect.left - 20 - bubbleElement.offsetWidth + window.scrollX;
                //     bubbleElement.style.left = `${maxLeft}px`;
                // }
              }
            }
          },

          // Record step in history (hidden)
          recordStepInHistory(step) {
            if (!this.elements.computationStepsHistory) return;

            // Clear history if this is the first step
            if (this.currentStep === 0) {
              this.elements.computationStepsHistory.innerHTML = "";
            }

            const stepElement = document.createElement("div");
            stepElement.className = "computation-step";

            // Add step to history with all previous steps
            if (step.explanation && step.explanation.length) {
              const explanationHtml = `
                            <div class="step-explanation">
                                <ul>
                                    ${step.explanation
                                      .map((line) => `<li>${line}</li>`)
                                      .join("")}
                                </ul>
                            </div>
                        `;
              stepElement.innerHTML = explanationHtml;
            }

            this.elements.computationStepsHistory.appendChild(stepElement);
          },
          // Visualize the original array
          visualizeOriginalArray(array) {
            if (!this.elements.originalArrayContainer) return;

            this.elements.originalArrayContainer.innerHTML = "";

            // Add invisible placeholder for index 0 to align with prefix sum array
            const placeholderElement = document.createElement("div");
            placeholderElement.className = "placeholder-element";
            this.elements.originalArrayContainer.appendChild(
              placeholderElement
            );

            // Create and append array elements
            array.forEach((value, index) => {
              const element = document.createElement("div");
              element.className = "array-element original-array-element";

              // Create value span
              const valueSpan = document.createElement("span");
              valueSpan.className = "element-value";
              valueSpan.textContent = value;
              element.appendChild(valueSpan);

              // Create index span
              const indexSpan = document.createElement("span");
              indexSpan.className = "element-index original-array-index";
              indexSpan.textContent = index + 1; // 1-indexed display
              element.appendChild(indexSpan);

              this.elements.originalArrayContainer.appendChild(element);
            });
          },
          // Visualize the prefix sum array
          visualizePrefixSumArray(prefixSumArray) {
            if (!this.elements.prefixSumArrayContainer) return;

            this.elements.prefixSumArrayContainer.innerHTML = "";

            // Create and append array elements - MAKE SURE TO INCLUDE INDEX 0
            prefixSumArray.forEach((value, index) => {
              const element = document.createElement("div");
              element.className = "array-element prefix-sum-array-element";

              const valueSpan = document.createElement("span");
              valueSpan.className = "element-value";
              valueSpan.textContent = value;

              const indexSpan = document.createElement("span");
              indexSpan.className = "element-index prefix-sum-array-index";
              indexSpan.textContent = index; // 0-indexed for prefix sum

              element.appendChild(valueSpan);
              element.appendChild(indexSpan);

              this.elements.prefixSumArrayContainer.appendChild(element);
            });
          },
          // Highlight an element in an array visualization
          highlightArrayElement(containerId, index) {
            const container = document.getElementById(containerId);
            if (!container) return null;

            const elements = container.querySelectorAll(".array-element");

            // Add highlight to the specified element
            if (index >= 0 && index < elements.length) {
              elements[index].classList.add("active");
              return elements[index]; // Return the element for animation chaining
            }

            return null;
          },

          // Shuffle the current array
          shuffleArray() {
            // Utility function to shuffle array
            const shuffleArray = (array) => {
              const newArray = [...array];
              for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
              }
              return newArray;
            };

            // Get current array from UI
            const array = this.getArrayFromUI();
            if (array.length === 0) {
              alert("Vui lòng nhập ít nhất một phần tử cho mảng!");
              return;
            }

            // Shuffle the array
            const shuffledArray = shuffleArray(array);

            // Update the UI with shuffled array
            this.updateArrayItemsInUI(shuffledArray);

            // Reset visualizations since array changed
            this.resetVisualization();
          },

          // Update array items in the UI with new values
          updateArrayItemsInUI(array) {
            if (!this.elements.arrayContainer) return;

            // Remove existing array items
            const arrayItems =
              this.elements.arrayContainer.querySelectorAll(".array-item");
            arrayItems.forEach((item) => item.remove());

            // Add new array items
            array.forEach((value) => {
              this.addArrayElement(value);
            });
          },
          // Execute and visualize a range sum query
          executeAndVisualizeQuery() {
            if (!this.prefixSumArray || this.prefixSumArray.length <= 1) {
              alert("Vui lòng tính mảng cộng dồn trước!");
              return;
            }

            // Get query range values
            const left = parseInt(this.elements.queryLInput.value);
            const right = parseInt(this.elements.queryRInput.value);

            // Validate range
            if (
              isNaN(left) ||
              isNaN(right) ||
              left < 1 ||
              right < left ||
              right > this.originalArray.length
            ) {
              alert(
                `Vui lòng nhập giá trị L và R hợp lệ (1 ≤ L ≤ R ≤ ${this.originalArray.length})`
              );
              return;
            } // Clear previous visualizations including boundary markers
            if (this.elements.queryArrays) {
              const existingMarkers =
                this.elements.queryArrays.querySelectorAll(".boundary-marker");
              existingMarkers.forEach((marker) => marker.remove());
            }

            // Also remove any boundary indicators from the entire document
            const boundaryIndicators = document.querySelectorAll(
              ".boundary-indicator"
            );
            boundaryIndicators.forEach((indicator) => indicator.remove());

            // Calculate range sum
            const rangeSum =
              this.prefixSumArray[right] - this.prefixSumArray[left - 1];

            // Update formula display
            if (this.elements.formulaSR) {
              this.elements.formulaSR.textContent = this.prefixSumArray[right];
            }

            if (this.elements.formulaSL1) {
              this.elements.formulaSL1.textContent =
                this.prefixSumArray[left - 1];
            }

            if (this.elements.formulaResult) {
              this.elements.formulaResult.textContent = rangeSum;
            }

            // Visualize the query on original array
            this.visualizeQueryOnOriginalArray(left, right);

            // Visualize the array segments
            this.visualizeArraySegments(left, right);

            // Automatically scroll to visualization results
            setTimeout(() => {
              const queryVisualizationSection = document.getElementById(
                "query-visualization-section"
              );
              if (queryVisualizationSection) {
                queryVisualizationSection.scrollIntoView({
                  behavior: "smooth",
                  block: "start",
                });
              }
            }, 100);
          },
          // Visualize the query on the original array
          visualizeQueryOnOriginalArray(left, right) {
            if (
              !this.elements.queryOriginalArray ||
              !this.elements.queryPrefixSumArray
            )
              return; // Clear previous visualizations
            this.elements.queryOriginalArray.innerHTML = "";
            this.elements.queryPrefixSumArray.innerHTML = "";

            // Remove any existing boundary markers to prevent overlay
            const existingMarkers =
              this.elements.queryArrays.querySelectorAll(".boundary-marker");
            existingMarkers.forEach((marker) => marker.remove());

            // Also remove any boundary indicators
            const boundaryIndicators = document.querySelectorAll(
              ".boundary-indicator"
            );
            boundaryIndicators.forEach((indicator) => indicator.remove());

            // Set CSS variables for L and R positions
            document.documentElement.style.setProperty(
              "--L-position",
              left - 1
            );
            document.documentElement.style.setProperty(
              "--R-position",
              right - 1
            );

            // Add placeholder for index 0 in original array to align with prefix sum
            const placeholderElement = document.createElement("div");
            placeholderElement.className = "placeholder-element";
            this.elements.queryOriginalArray.appendChild(placeholderElement);

            // Add L marker to query arrays container
            const lMarker = document.createElement("div");
            lMarker.className = "boundary-marker L-marker";
            lMarker.textContent = "L=" + left;
            this.elements.queryArrays.appendChild(lMarker);

            // Add R marker to query arrays container
            const rMarker = document.createElement("div");
            rMarker.className = "boundary-marker R-marker";
            rMarker.textContent = "R=" + right;
            this.elements.queryArrays.appendChild(rMarker);

            // Visualize the original array with range highlighting
            this.originalArray.forEach((value, index) => {
              // Create element for original array
              const element = document.createElement("div");
              element.className = "array-element original-array-element";
              if (index >= left - 1 && index < right) {
                element.classList.add("active"); // Highlight elements in range
              }

              // Create value span
              const valueSpan = document.createElement("span");
              valueSpan.className = "element-value";
              valueSpan.textContent = value;
              element.appendChild(valueSpan);

              // Create index span
              const indexSpan = document.createElement("span");
              indexSpan.className = "element-index original-array-index";
              indexSpan.textContent = index + 1; // 1-indexed display
              element.appendChild(indexSpan);

              this.elements.queryOriginalArray.appendChild(element);
            });

            // Add a copy of the prefix sum array to the query section
            // First, add the S[0] element
            const s0Element = document.createElement("div");
            s0Element.className = "array-element prefix-sum-array-element";
            const s0ValueSpan = document.createElement("span");
            s0ValueSpan.className = "element-value";
            s0ValueSpan.textContent = "0";
            const s0IndexSpan = document.createElement("span");
            s0IndexSpan.className = "element-index prefix-sum-array-index";
            s0IndexSpan.textContent = "0";
            s0Element.appendChild(s0ValueSpan);
            s0Element.appendChild(s0IndexSpan);
            this.elements.queryPrefixSumArray.appendChild(s0Element);

            // Then add the rest of the prefix sum elements
            for (let i = 1; i <= this.originalArray.length; i++) {
              const sElement = document.createElement("div");
              sElement.className = "array-element prefix-sum-array-element";

              // Highlight special positions (L-1, R)
              if (i === left - 1) {
                sElement.classList.add("active");
                sElement.style.borderColor = "var(--query-left-color)";
              } else if (i === right) {
                sElement.classList.add("active");
                sElement.style.borderColor = "var(--query-right-color)";
              }

              const sValueSpan = document.createElement("span");
              sValueSpan.className = "element-value";
              sValueSpan.textContent = this.prefixSumArray[i];

              const sIndexSpan = document.createElement("span");
              sIndexSpan.className = "element-index prefix-sum-array-index";
              sIndexSpan.textContent = i;

              sElement.appendChild(sValueSpan);
              sElement.appendChild(sIndexSpan);

              this.elements.queryPrefixSumArray.appendChild(sElement);
            }
          }, // Visualize the array segments for the query
          visualizeArraySegments(left, right) {
            if (
              !this.elements.segmentLeft ||
              !this.elements.segmentMiddle ||
              !this.elements.segmentRight
            )
              return;
            // Clear previous visualizations
            this.elements.segmentLeft.innerHTML = "";
            this.elements.segmentMiddle.innerHTML = "";
            this.elements.segmentRight.innerHTML = "";

            // Also make sure to clean up any stray boundary indicators that might not be in the segments
            const boundaryIndicators = document.querySelectorAll(
              ".boundary-indicator"
            );
            boundaryIndicators.forEach((indicator) => indicator.remove());

            // A[1..L-1] segment
            if (left > 1) {
              // Add placeholders before 1 to align with the complete array
              for (let i = 0; i < 1; i++) {
                const placeholder = document.createElement("div");
                placeholder.className = "segment-placeholder";
                this.elements.segmentLeft.appendChild(placeholder);
              }

              // Add the segment elements (showing original array values)
              for (let i = 1; i < left; i++) {
                const element = document.createElement("div");
                element.className = "segment-element segment-element-left";
                element.textContent = this.originalArray[i - 1]; // using originalArray
                this.elements.segmentLeft.appendChild(element);
              }

              // Add the sum display - still show prefix sum as the result
              const sumElement = document.createElement("div");
              sumElement.className = "segment-sum segment-sum-left";
              sumElement.textContent = `= ${this.prefixSumArray[left - 1]}`;
              this.elements.segmentLeft.appendChild(sumElement);
            } else {
              const emptyMessage = document.createElement("div");
              emptyMessage.textContent = "Không có phần tử (L=1)";
              emptyMessage.className = "empty-segment";
              this.elements.segmentLeft.appendChild(emptyMessage);
            } // A[L..R] segment (the queried range)
            // Clear previous content and indicators
            this.elements.segmentMiddle.innerHTML = "";

            // Add placeholders before L to align with the complete array
            for (let i = 0; i < left; i++) {
              const placeholder = document.createElement("div");
              placeholder.className = "segment-placeholder";
              this.elements.segmentMiddle.appendChild(placeholder);
            }

            // Add L boundary indicator
            const lBoundary = document.createElement("div");
            lBoundary.className = "boundary-indicator boundary-L";
            lBoundary.textContent = "L";
            this.elements.segmentMiddle.appendChild(lBoundary);

            for (let i = left; i <= right; i++) {
              const element = document.createElement("div");
              element.className = "segment-element segment-element-range";
              element.textContent = this.originalArray[i - 1]; // using originalArray
              this.elements.segmentMiddle.appendChild(element);
            }

            // Add R boundary indicator
            const rBoundary = document.createElement("div");
            rBoundary.className = "boundary-indicator boundary-R";
            rBoundary.textContent = "R";
            this.elements.segmentMiddle.appendChild(rBoundary);

            // Add the sum (result of subtraction) - still show the result
            const sumElement = document.createElement("div");
            sumElement.className = "segment-sum segment-sum-range";
            const rangeSum =
              this.prefixSumArray[right] - this.prefixSumArray[left - 1];
            sumElement.textContent = `= ${rangeSum}`;
            this.elements.segmentMiddle.appendChild(sumElement);

            // A[1..R] segment
            // Add placeholders before 1 to align with the complete array
            for (let i = 0; i < 1; i++) {
              const placeholder = document.createElement("div");
              placeholder.className = "segment-placeholder";
              this.elements.segmentRight.appendChild(placeholder);
            }

            for (let i = 1; i <= right; i++) {
              const element = document.createElement("div");
              element.className = "segment-element";

              // Use different colors for elements before L and from L to R
              if (i < left) {
                element.classList.add("segment-element-left");
              } else {
                element.classList.add("segment-element-range");
              }

              element.textContent = this.originalArray[i - 1]; // using originalArray
              this.elements.segmentRight.appendChild(element);
            }

            // Add the sum display - still show prefix sum as the result
            const rightSumElement = document.createElement("div");
            rightSumElement.className = "segment-sum segment-sum-right";
            rightSumElement.textContent = `= ${this.prefixSumArray[right]}`;
            this.elements.segmentRight.appendChild(rightSumElement);
          },
          // Update query range controls based on array size
          updateQueryRangeControls(arraySize) {
            if (!this.elements.querySection || !this.elements.rangeLabels)
              return;

            // Show the query section
            this.elements.querySection.style.display = "block";

            // Update handle min/max values
            this.handleValues.left.min = 1;
            this.handleValues.left.max = arraySize;
            this.handleValues.left.value = 1;

            this.handleValues.right.min = 1;
            this.handleValues.right.max = arraySize;
            this.handleValues.right.value = arraySize;

            // Update handle positions
            this.updateLeftHandlePosition();
            this.updateRightHandlePosition();

            // Update the query input values
            if (this.elements.queryLInput) this.elements.queryLInput.value = 1;
            if (this.elements.queryRInput)
              this.elements.queryRInput.value = arraySize;

            // Generate range labels
            this.elements.rangeLabels.innerHTML = "";

            // Also update floating slider
            this.updateFloatingSliderValues();
          },

          // Set up the floating range slider
          setupFloatingRangeSlider() {
            if (
              !this.elements.floatingSliderContainer ||
              !this.elements.floatingLeftHandle ||
              !this.elements.floatingRightHandle
            )
              return;

            // Function to check scroll position and show/hide floating slider
            const checkScrollPosition = () => {
              if (!this.elements.rangeSliderContainer) return;

              const rangeSliderRect =
                this.elements.rangeSliderContainer.getBoundingClientRect();

              // If the original slider is out of view (above the viewport)
              if (rangeSliderRect.bottom < 0) {
                this.elements.floatingSliderContainer.classList.add("visible");
              } else {
                this.elements.floatingSliderContainer.classList.remove(
                  "visible"
                );
              }
            };

            // Set up scroll event listener
            window.addEventListener("scroll", checkScrollPosition);

            // Set up dragging for floating left handle
            this.setupDragging(this.elements.floatingLeftHandle, true, true);

            // Set up dragging for floating right handle
            this.setupDragging(this.elements.floatingRightHandle, false, true);
          },

          // Update floating slider values from the main sliders
          updateFloatingSliderValues() {
            if (
              !this.elements.floatingValueLeft ||
              !this.elements.floatingValueRight
            )
              return;

            // Update floating slider values display
            this.elements.floatingValueLeft.textContent = `L=${this.handleValues.left.value}`;
            this.elements.floatingValueRight.textContent = `R=${this.handleValues.right.value}`;

            // Update floating handle positions
            if (this.elements.floatingLeftHandle) {
              const leftPosition =
                ((this.handleValues.left.value - this.handleValues.left.min) /
                  (this.handleValues.left.max - this.handleValues.left.min)) *
                100;
              this.elements.floatingLeftHandle.style.left = `${leftPosition}%`;
            }

            if (this.elements.floatingRightHandle) {
              const rightPosition =
                ((this.handleValues.right.value - this.handleValues.right.min) /
                  (this.handleValues.right.max - this.handleValues.right.min)) *
                100;
              this.elements.floatingRightHandle.style.left = `${rightPosition}%`;
            }
          },

          // Update all sliders (both floating and regular) to stay in sync
          updateAllSliders() {
            // Update left input field
            if (this.elements.queryLInput) {
              this.elements.queryLInput.value = this.handleValues.left.value;
            }

            // Update right input field
            if (this.elements.queryRInput) {
              this.elements.queryRInput.value = this.handleValues.right.value;
            }

            // Update main sliders visual position
            if (this.elements.leftHandle) {
              const leftPosition =
                ((this.handleValues.left.value - this.handleValues.left.min) /
                  (this.handleValues.left.max - this.handleValues.left.min)) *
                100;
              this.elements.leftHandle.style.left = `${leftPosition}%`;
            }

            if (this.elements.rightHandle) {
              const rightPosition =
                ((this.handleValues.right.value - this.handleValues.right.min) /
                  (this.handleValues.right.max - this.handleValues.right.min)) *
                100;
              this.elements.rightHandle.style.left = `${rightPosition}%`;
            }

            // Update floating slider values and positions
            this.updateFloatingSliderValues();

            // Perform the query with updated values
            this.performQuery();
          },
          // Perform a query based on the current slider values
          performQuery() {
            // Only perform if we have prefix sum data
            if (!this.prefixSumArray || this.prefixSumArray.length <= 1) return;

            // Clear any existing boundary markers first
            if (this.elements.queryArrays) {
              const existingMarkers =
                this.elements.queryArrays.querySelectorAll(".boundary-marker");
              existingMarkers.forEach((marker) => marker.remove());
            }

            // Also remove any boundary indicators
            const boundaryIndicators = document.querySelectorAll(
              ".boundary-indicator"
            );
            boundaryIndicators.forEach((indicator) => indicator.remove());

            const left = this.handleValues.left.value;
            const right = this.handleValues.right.value;

            // Calculate range sum
            const rangeSum =
              this.prefixSumArray[right] - this.prefixSumArray[left - 1];

            // Update formula display
            if (this.elements.formulaSR) {
              this.elements.formulaSR.textContent = this.prefixSumArray[right];
            }

            if (this.elements.formulaSL1) {
              this.elements.formulaSL1.textContent =
                this.prefixSumArray[left - 1];
            }

            if (this.elements.formulaResult) {
              this.elements.formulaResult.textContent = rangeSum;
            }

            // Visualize the query on original array
            this.visualizeQueryOnOriginalArray(left, right);

            // Visualize the array segments
            this.visualizeArraySegments(left, right);
          },

          // Update handles based on query input fields
          updateHandlesFromQuery() {
            const left = parseInt(this.elements.queryLInput.value);
            const right = parseInt(this.elements.queryRInput.value);

            // Validate the values
            if (
              isNaN(left) ||
              isNaN(right) ||
              left < this.handleValues.left.min ||
              right > this.handleValues.right.max
            ) {
              return;
            }

            // Adjust values to ensure left <= right
            const adjustedLeft = Math.min(left, right);
            const adjustedRight = Math.max(left, right);

            // Update handle values
            this.handleValues.left.value = adjustedLeft;
            this.handleValues.right.value = adjustedRight;

            // Update input fields if values were adjusted
            if (adjustedLeft !== left) {
              this.elements.queryLInput.value = adjustedLeft;
            }
            if (adjustedRight !== right) {
              this.elements.queryRInput.value = adjustedRight;
            }

            // Update visual positions of handles
            this.updateAllSliders();
          },

          // Update query based on handle positions
          updateQueryFromHandles() {
            // Update input field values
            if (this.elements.queryLInput) {
              this.elements.queryLInput.value = this.handleValues.left.value;
            }
            if (this.elements.queryRInput) {
              this.elements.queryRInput.value = this.handleValues.right.value;
            }

            // Update floating slider values
            this.updateFloatingSliderValues();

            // Perform the query with the current values
            this.performQuery();
          },
        };

        // Initialize the visualization object
        window.PrefixSumVisualization.init();
      });
    </script>
  </body>
</html>
